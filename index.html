<html>

<script src='https://d3js.org/d3.v5.min.js'></script>

<style>

svg {
    border: 1px solid black;
}

body {
    border: 1px solid grey;
}

</style>

<body onload='init()'>
<div id="tooltip1" style="display: none;"></div>
<div id="tooltip2" style="display: none;"></div>
<div id="tooltip3" style="display: none;"></div>
<svg id="svg1" style="display: none;"></svg>
<svg id="svg2" style="display: none;"></svg>
<div class="svg-container">
    <svg id="svg3" style="display: none;"></svg>
</div>

<script>
// Global variables
var data = null
var dataDict = null

async function init() {
    // Clear page
    d3.selectAll("svg").html("")

    // Get Data
    const originalData = await d3.csv('https://raw.githubusercontent.com/benhtan/beatTheMarket/main/S%26P500%20Prices.csv')
    // console.log(originalData)

    // Data cleanup. Format date to a date object, only use Open price as price
    data = [] // Array of objects with key date and price
    dataDict = {} // Object with key actual date and price

    originalData.forEach( element => {
        monthDayYear = element["Date"].split("/")

        if (parseInt("20" + monthDayYear[2]) > 2020) {
            monthDayYear[2] = "19" + monthDayYear[2]
        }
        else {
            monthDayYear[2] = "20" + monthDayYear[2]
        }

        for (let i = 0; i < monthDayYear.length; i++) {
            monthDayYear[i] = parseInt( monthDayYear[i] )
            // console.log(monthDayYear[i])
        }
        // console.log(monthDayYear)
        // console.log(`${element[" Open"]} ${parseFloat( element[" Open"] )}`)

        let date = new Date( monthDayYear[2], monthDayYear[0] - 1, monthDayYear[1] )
        let price = parseFloat( element[" Open"] )

        dataDict[`${monthDayYear[2]}-${monthDayYear[0] - 1}-${monthDayYear[1]}`] = price

        data.push( 
            {
                date: date, 
                price: price
            }
        )
    })

    // console.log(data)
    console.log(dataDict)
    // console.log(dataDict[new Date(2000, 1, 1)])

    createInteractivePlot(data, dataDict, "#svg3", "#tooltip3")

    d3.select(window).on('resize', init)
}

function createInteractivePlot(data, dataDict, svg, tooltip) {
    const bodySize = document.querySelector("body").getBoundingClientRect()

    // Set svg canvas
    const svgWidth = bodySize.width * .75
    const svgHeight = svgWidth/2
    const plotMargin = 50
    const plotWidth = svgWidth - plotMargin*2
    const plotHeight = svgHeight - plotMargin*2

    const svg3 = d3.select(svg)
    .attr("width", svgWidth)
    .attr("height", svgHeight)
    .style("display", "block")
    .style("position", "absolute")  // needed for z index
    .style("z-index", "99") // so that svg is always above everything else

    // Scale
    var xScale = d3.scaleTime().domain( [data[data.length-1].date, data[0].date] ).range([0, plotWidth])
    var yScale = d3.scaleLinear().domain( [0.00, 4000.00] ).range( [plotHeight, 0] )
    // console.log(yScale(2000))
    // console.log( xScale(data[2000].date) )
    // console.log(data[2000].date)

    // Plot
    // d3.select("#svg1")
    // .append("g")
    // .attr("transform", `translate(${plotMargin},${plotMargin})`) 
    // .selectAll("circle")
    // .data(data)
    // .enter()
    // .append("circle")
    // .attr( "cx", function (d) {return xScale( d.date )} )
    // .attr( "cy", function (d) {return yScale( d.price )} )
    // .attr("r",  0.5)

    const line = d3.line()
                .x(d => xScale( d.date ))
                .y(d => yScale( d.price ))

    d3.select(svg)
    .append("g")
    .attr("transform", `translate(${plotMargin},${plotMargin})`)
    .append("path")
    .datum(data)
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-width", .5)
    .attr("d", line)

    // Y Label
    d3.select(svg)
    .append("g")
    .attr("transform", `translate(${plotMargin},${plotMargin})`)
    .call( d3.axisLeft(yScale) )

    // X Label
    d3.select(svg)
    .append("g")
    .attr("transform", `translate(${plotMargin},${plotHeight + plotMargin})`)
    .call( d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y")) )

    // Create tooltip vertical line
    d3.select(svg)
    .append("path")
    .attr("id", `toolTipLine${tooltip.substring(1)}`)

    // Create tooltip circle
    d3.select(svg)
    .append("circle")
    .attr("id", `toolTipCircle${tooltip.substring(1)}`)

    // Tool tip
    d3.selectAll(svg, tooltip, `#toolTipLine${tooltip.substring(1)}`, `#toolTipCircle${tooltip.substring(1)}`)
    .on("mousemove", () => {
        removeToolTip(tooltip)
        // Get size and location of svg
        const svgCoord = document.querySelector(svg).getBoundingClientRect()

        // Debugging
        // d3.select("#tooltip1").html(d3.event.pageX + " " + d3.event.pageY)
        // d3.select("#tooltip2").html(parseInt(d3.event.pageX - svgCoord.x) + " " + parseInt(d3.event.pageY - svgCoord.y))

        // Find relation between cursor location and plot data
        let cursorXLocationRelativeToPlot = d3.event.pageX - svgCoord.x - plotMargin // cursor location will be 0 and Y axis of plot
        let date = xScale.invert(parseInt(cursorXLocationRelativeToPlot))
        let dateFormatted = formatDate(date)
        let nextTradingDayPrice = null

        // Handle problem where cursor is not at a valid trading day
        if (dateFormatted in dataDict === false) {
            // console.log(dateFormatted)
            nextTradingDayPrice = findNextTradingDayPrice(dateFormatted, dataDict)
        }
        
        // Create date & price tooltip
        d3.select(tooltip).style("display", "block").style("position", "absolute")
        .html(`${nextTradingDayPrice ? nextTradingDayPrice : dataDict[dateFormatted]} USD - ${prettifyDate(date)}`)

        let toolTipCoord = document.querySelector(tooltip).getBoundingClientRect()    // Get tooltip size

        // Figuring out where tooltip div left should be. Tooltip div should not go outside of plot in x direction
        if (cursorXLocationRelativeToPlot - toolTipCoord.width/2 <= 0) {var toolTipLeft = plotMargin + svgCoord.x}
        else if (cursorXLocationRelativeToPlot + toolTipCoord.width/2 >= plotWidth) {var toolTipLeft = plotMargin + plotWidth + svgCoord.x - toolTipCoord.width}
        else {var toolTipLeft = d3.event.pageX - toolTipCoord.width/2}

        d3.select(tooltip)
        .style("top", svgCoord.y + plotMargin / 2)
        .style("left", toolTipLeft) // Displaying tooltip div centered to cursor

        // debugging print
        // d3.select("#tooltip1").style("display", "block")
        // .html(`${d3.event.pageX} ${cursorXLocationRelativeToPlot} ${toolTipCoord.width}`)

        // Create tooltip vertical line
        const lineCircXCoord = d3.event.pageX - svgCoord.x + 2 // add one pixel so cursor is never on top of line, always on top of svg
        var toolTipLine = d3.line()([[lineCircXCoord, plotMargin], [lineCircXCoord, plotHeight + plotMargin]])
        if (d3.event.pageX - svgCoord.x < plotMargin || d3.event.pageX - svgCoord.x > plotWidth + plotMargin) {
            removeToolTip(tooltip)
        }
        else {
            // Show line
            d3.select(`#toolTipLine${tooltip.substring(1)}`)
            .attr("d", toolTipLine)
            .attr("fill", "none")
            .attr("stroke", "black")
            .attr("stroke-width", .5)
            
            // Show circle
            d3.select(`#toolTipCircle${tooltip.substring(1)}`)
            .attr("cx", lineCircXCoord)
            .attr("cy", yScale( nextTradingDayPrice ? nextTradingDayPrice : dataDict[dateFormatted] ) + plotMargin)
            .attr("r", 4)
        }
    })
    .on( "mouseout", () => {removeToolTip(tooltip)} )
}

function removeToolTip(tooltip) {
    // Remove line
    d3.select(`#toolTipLine${tooltip.substring(1)}`)
            .attr("stroke-width", 0)

    // Remove circle
    d3.select(`#toolTipCircle${tooltip.substring(1)}`)
    .attr("r", 0)

    // Remove details
    d3.select(tooltip).style("display", "none")
}

function findNextTradingDayPrice(d, dataDict) {
    const yearMonthDay = d.split("-")
    var date = new Date(yearMonthDay[0], yearMonthDay[1], yearMonthDay[2])
    for (let i = 0; i < 7; i++) {
        date.setDate(date.getDate() + 1);
        // console.log(formatDate(date))
        if (formatDate(date) in dataDict) {
            // console.log(`${date}`)
            break
        }
    }
    return dataDict[formatDate(date)]
    
    // console.log(`${d}   ${date}    ${prevDayDate}`)
}

function formatDate(date) {
    return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`
}

function prettifyDate(date) {
    let dateStringArray = date.toString().split(" ")
    return `${dateStringArray[1]} ${dateStringArray[2]}, ${dateStringArray[3]}`
}

</script>
</body>
</html>
