<html>

<script src='https://d3js.org/d3.v5.min.js'></script>

<style>
svg {
    border: 1px solid black;
}
</style>

<body onload='init()'>
<div id="tooltip1" style="display: none;"></div>
<div id="tooltip2" style="display: none;"></div>
<div id="tooltip3" style="display: none;"></div>
<svg id="svg1" style="display: none;"></svg>
<svg id="svg2" style="display: none;"></svg>
<svg id="svg3" style="display: none;"></svg>

<script>
async function init() {
    // Get Data
    const originalData = await d3.csv('https://raw.githubusercontent.com/benhtan/beatTheMarket/main/S%26P500%20Prices.csv')
    // console.log(originalData)

    // Data cleanup. Format date to a date object, only use Open price as price
    const data = [] // Array of objects with key date and price
    const dataDict = {} // Object with key actual date and price

    originalData.forEach( element => {
        monthDayYear = element["Date"].split("/")

        if (parseInt("20" + monthDayYear[2]) > 2020) {
            monthDayYear[2] = "19" + monthDayYear[2]
        }
        else {
            monthDayYear[2] = "20" + monthDayYear[2]
        }

        for (let i = 0; i < monthDayYear.length; i++) {
            monthDayYear[i] = parseInt( monthDayYear[i] )
            // console.log(monthDayYear[i])
        }
        // console.log(monthDayYear)
        // console.log(`${element[" Open"]} ${parseFloat( element[" Open"] )}`)

        let date = new Date( monthDayYear[2], monthDayYear[0] - 1, monthDayYear[1] )
        let price = parseFloat( element[" Open"] )

        dataDict[`${monthDayYear[2]}-${monthDayYear[0] - 1}-${monthDayYear[1]}`] = price

        data.push( 
            {
                date: date, 
                price: price
            }
        )
    })

    // console.log(data)
    console.log(dataDict)
    // console.log(dataDict[new Date(2000, 1, 1)])

    createInteractivePlot(data, dataDict, "#svg3", "#tooltip3")
}

function createInteractivePlot(data, dataDict, svg, tooltip) {
    // Set svg canvas
    const svgWidth = 1000
    const svgHeight = 500
    const plotMargin = 50
    const plotWidth = svgWidth - plotMargin*2
    const plotHeight = svgHeight - plotMargin*2

    const svg3 = d3.select(svg)
    .attr("width", svgWidth)
    .attr("height", svgHeight)
    .style("display", "block")
    // .style("position", "absolute")  // needed for z index
    // .style("z-index", "99") // so that svg is always above everything else

    // Scale
    var xScale = d3.scaleTime().domain( [data[data.length-1].date, data[0].date] ).range([0, plotWidth])
    var yScale = d3.scaleLinear().domain( [0.00, 4000.00] ).range( [plotHeight, 0] )
    // console.log(yScale(2000))
    // console.log( xScale(data[2000].date) )
    // console.log(data[2000].date)

    // Plot
    // d3.select("#svg1")
    // .append("g")
    // .attr("transform", `translate(${plotMargin},${plotMargin})`) 
    // .selectAll("circle")
    // .data(data)
    // .enter()
    // .append("circle")
    // .attr( "cx", function (d) {return xScale( d.date )} )
    // .attr( "cy", function (d) {return yScale( d.price )} )
    // .attr("r",  0.5)

    const line = d3.line()
                .x(d => xScale( d.date ))
                .y(d => yScale( d.price ))

    d3.select(svg)
    .append("g")
    .attr("transform", `translate(${plotMargin},${plotMargin})`)
    .append("path")
    .datum(data)
    .attr("fill", "none")
    .attr("stroke", "black")
    .attr("stroke-width", .5)
    .attr("d", line)

    // Y Label
    d3.select(svg)
    .append("g")
    .attr("transform", `translate(${plotMargin},${plotMargin})`)
    .call( d3.axisLeft(yScale) )

    // X Label
    d3.select(svg)
    .append("g")
    .attr("transform", `translate(${plotMargin},${plotHeight + plotMargin})`)
    .call( d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y")) )

    // Create tooltip vertical line
    d3.select(svg)
    .append("path")
    .attr("id", `toolTipLine${tooltip.substring(1)}`)

    // Create tooltip circle
    d3.select(svg)
    .append("circle")
    .attr("id", `toolTipCircle${tooltip.substring(1)}`)

    // Tool tip
    d3.select(svg, tooltip, `#toolTipLine${tooltip.substring(1)}`, `#toolTipCircle${tooltip.substring(1)}`)
    .on("mousemove", () => {
        removeToolTip(tooltip)
        // Get size and location of svg
        const svgCoord = document.querySelector(svg).getBoundingClientRect()

        // d3.select("#tooltip1").html(d3.event.pageX + " " + d3.event.pageY)
        // d3.select("#tooltip2").html(parseInt(d3.event.pageX - svgCoord.x) + " " + parseInt(d3.event.pageY - svgCoord.y))

        // Find relation between cursor location and plot data
        let date = xScale.invert(parseInt(d3.event.pageX - svgCoord.x - plotMargin))
        let dateFormatted = formatDate(date)
        let nextTradingDayPrice = null

        // Handle problem where cursor is not at a valid trading day
        if (dateFormatted in dataDict === false) {
            // console.log(dateFormatted)
            nextTradingDayPrice = findNextTradingDayPrice(dateFormatted, dataDict)
        }
        
        // Create date & price tooltip
        d3.select(tooltip)
        .html(`${nextTradingDayPrice ? nextTradingDayPrice : dataDict[dateFormatted]} USD - ${prettifyDate(date)}`)

        let toolTipCoord = document.querySelector(tooltip).getBoundingClientRect()    // Get tooltip size

        d3.select(tooltip).style("display", "block").style("position", "absolute")
        .style("top", svgCoord.y + plotMargin / 2)
        .style("left", d3.event.pageX) // Displaying tooltip div centered to cursor


        d3.select("#tooltip1").style("display", "block")
        .html(`${d3.event.pageX} ${toolTipCoord}`)

        // Create tooltip vertical line
        var toolTipLine = d3.line()([[d3.event.pageX - svgCoord.x, plotMargin], [d3.event.pageX - svgCoord.x, plotHeight + plotMargin]])
        if (d3.event.pageX - svgCoord.x < plotMargin || d3.event.pageX - svgCoord.x > plotWidth + plotMargin) {
            removeToolTip(tooltip)
        }
        else {
            // Show line
            d3.select(`#toolTipLine${tooltip.substring(1)}`)
            .attr("d", toolTipLine)
            .attr("fill", "none")
            .attr("stroke", "black")
            .attr("stroke-width", .5)
            
            // Show circle
            d3.select(`#toolTipCircle${tooltip.substring(1)}`)
            .attr("cx", d3.event.pageX - svgCoord.x)
            .attr("cy", yScale( nextTradingDayPrice ? nextTradingDayPrice : dataDict[dateFormatted] ) + plotMargin)
            .attr("r", 4)
        }
    })
    .on( "mouseout", () => {removeToolTip(tooltip)} )
}

function removeToolTip(tooltip) {
    // Remove line
    d3.select(`#toolTipLine${tooltip.substring(1)}`)
            .attr("stroke-width", 0)

    // Remove circle
    d3.select(`#toolTipCircle${tooltip.substring(1)}`)
    .attr("r", 0)

    // Remove details
    d3.select(tooltip).style("display", "none")
}

function findNextTradingDayPrice(d, dataDict) {
    const yearMonthDay = d.split("-")
    var date = new Date(yearMonthDay[0], yearMonthDay[1], yearMonthDay[2])
    for (let i = 0; i < 7; i++) {
        date.setDate(date.getDate() + 1);
        // console.log(formatDate(date))
        if (formatDate(date) in dataDict) {
            // console.log(`${date}`)
            break
        }
    }
    return dataDict[formatDate(date)]
    
    // console.log(`${d}   ${date}    ${prevDayDate}`)
}

function formatDate(date) {
    return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`
}

function prettifyDate(date) {
    let dateStringArray = date.toString().split(" ")
    return `${dateStringArray[1]} ${dateStringArray[2]}, ${dateStringArray[3]}`
}

</script>
</body>
</html>
